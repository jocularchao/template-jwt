# 前后端分离项目模板基于token

包括登录、注册和密码重置等功能，可以二次开发编写具体场景下的应用程序

- 登录功能（支持用户名、邮箱登录）
- 注册用户（通过邮箱注册）
- 重置密码（通过邮箱重置密码）



## 后端

项目具体要创建的包和类以及功能都整合到了[结构化](###3 结构化)中



### 1 创建项目

#### 1.1 idea创建springboot项目

![image-20231228124927308](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228124927308.png)

#### 1.2 导入依赖

![image-20231228125004146](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228125004146.png)

#### 1.3 配置maven

![image-20231228125151992](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228125151992.png)

#### 1.4 清理干净项目

![image-20231212114532378](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114532378.png)

因为是前后端分离项目，后端不涉及前端页面，所以就把static、templates删掉

![image-20231212114718804](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114718804.png)



### 2 配置

#### 2.1 配置数据源

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/community?useUnicode=true&characterEncoding=utf-8
    username: root
    password: 123456
```

#### 2.2 配置springsecurity





##### 2.2.1 springsecurity配置类

![image-20231228132504898](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228132504898.png)

因为是前后端分离项目，所以肯定不是走springboot的服务器，要走前端的服务器

所以，我要把登陆等功能的接口单独定义出来

```java
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                //验证请求拦截和放行配置
                //爆红了背刺了，6.1版本更新这个方法过时了
                /*.authorizeHttpRequests()
                .anyRequest().permitAll()*/
                .authorizeHttpRequests(conf->conf
                        .requestMatchers("/api/auth/**").permitAll()    //所有验证的请求再用户没有登录的时候要允许通过
                        .anyRequest().authenticated()   //任何请求都不允许通过
                )
                //登录配置
                .formLogin(conf -> conf
                        .loginProcessingUrl("/api/auth/login")
                )
                //登出配置
                .logout(
                        conf -> conf
                        .logoutUrl("api/auth/logout")
                )
                .build();   //构建，返回默认的SecurityFilterChain对象
    }

    

}
```

运行测试以下，密码默认生成在控制台

![image-20231228181648025](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228181648025.png)

测试成功



当前台调用了我们后端的接口之后，我们要返回一个json的数据，告诉前端==>登录成功了或登出成功了 这样的信息

所以我们要重写并封装 处理我们登录成功或失败 的接口方便我们调用

```java
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        ...
 		//登录配置
        .formLogin(conf -> conf
                   .loginProcessingUrl("/api/auth/login")
                   .successHandler(this::onAuthenticationSuccess)
                   .failureHandler(this::onAuthenticationFailure)
        )
        //登出配置
        .logout(conf->conf
                   .logoutUrl("api/auth/logout")
                   .logoutSuccessHandler(this::onLogoutSuccess)
        )
            
    }
    
    //登录成功后的处理
    /**
     *
     * @param request   请求
     * @param response  响应
     * @param authentication    请求成功后的验证信息
     * @throws IOException  io异常
     * @throws ServletException servlet异常
     */
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        response.getWriter().write("登陆成功");
    }

    //登录失败后的处理
    public void onAuthenticationFailure(HttpServletRequest request,
                                        HttpServletResponse response,
                                        AuthenticationException exception) throws IOException, ServletException {

    }

    //登出成功的处理
    //虽然登出成功和登陆成功的参数一样，但由于我们在登出的时候会写一个让jwt失效的功能，所以不能写在一起
    public void onLogoutSuccess(HttpServletRequest request,
                                HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {

    }
            
}
```

配置一些其他设置，把csrf关掉并把sessionManager改成无状态

```java
...
//登出配置
.logout(conf->conf
        .logoutUrl("api/auth/logout")
        .logoutSuccessHandler(this::onLogoutSuccess)    //登出成功的处理
)
//取消CSRF保护
.csrf(AbstractHttpConfigurer::disable)
//因为我们现在是无状态的前后端分离跟有状态的前后端分离区别：session不需要去维护用户信息，因为用户信息都在JWT里面
//所以我们把sessionManagement改成无状态，让security不去处理session
.sessionManagement(conf->conf
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS) //改成无状态
)
.build();   //构建，返回默认的SecurityFilterChain对象
...
```

启动项目，测试

![image-20231228180057176](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228180057176.png)

![image-20231228183137996](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228183137996.png)





##### 2.2.2 记录类封装响应信息

​	创建记录类RestBean接收信息，返回更标准的数据,方便前端进行一个统一的判断

```java
/**
 *
 * @param code  状态码
 * @param data  数据
 * @param message   异常信息
 * @param <T>   具体的数据的类型不确定
 */
public record RestBean<T>(int code, T data,String message) {

    //请求成功
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200,data,"请求成功");
    }
    //默认的请求成功
    public static <T> RestBean<T> success(){
        return success(null);
    }
    public String asJsonString(){
        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);   //WriteNull 不加上的话，前端的lang就没有了
    }


    //请求失败
    public static <T> RestBean<T> failure(int code, String message){
        return new RestBean<>(code,null,message);
    }

}
```



##### 2.2.3 登录成功

在security配置类中输出实体类信息，并转换成json格式

导入fastjson依赖后

在登陆成功处输出实体类信息

```java
//登录成功后，
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");

    response.getWriter().write(RestBean.success().asJsonString());
}
```

![image-20231228202255570](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228202255570.png)

> ##### 为什么要转换成json数据
>
> 因为前端需要的就是这样的数据，前端会将json直接解析，非常方便



##### 2.2.4 登录失败

在security配置类定义登录失败接口

```java
//登录失败
public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
  //配置编码
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");

        response.getWriter().write(RestBean.failure(401,exception.getMessage()).asJsonString());
    
}
```

![image-20231212180940715](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212180940715.png)





##### 2.2.5 未登录情况请求

完成[jwt请求头校验](####4.3 jwt请求头校验)，在来进行未登录请求 因为 已经创建了jwt令牌，可以进行其他接口请求了

在没有登录的情况下请求，它会自动地返回登录页面

我们把它配置成 返回统一的json的数据

`SecurityConfiguration`:

```java
//注入jwt验证的过滤器
@Resource
JwtAuthorizeFilter jwtAuthorizeFilter;
...
				//异常处理
                .exceptionHandling(conf->conf
                        .authenticationEntryPoint(this::onUnauthorized) //未登录配置
                )
                ...
    //未登录的处理
    public void onUnauthorized(HttpServletRequest request,
                                HttpServletResponse response,
                                AuthenticationException exception) throws IOException {
        //配置编码
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");

        response.getWriter().write(RestBean.unauthorized(exception.getMessage()).asJsonString());
    }
```



没有给`authorization`这个请求头就是未登录，因为`authorization`中带有登陆时创建的jwt令牌

![image-20231230213648441](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231230213648441.png)



##### 2.2.6 登录但没权限

有些比如说 user 权限的用户，他们登录后，是没有权限访问管理员用户能访问的页面的

所以要配置登录了，但没权限的用户配置

`SecurityConfiguration`：

```java
	//异常处理
    .exceptionHandling(conf->conf
        .authenticationEntryPoint(this::onUnauthorized) //未登录配置
        .accessDeniedHandler(this::onAccessDeny)  //登录但没权限
    )

//登录但没权限
public void onAccessDeny(HttpServletRequest request,
                                HttpServletResponse response,
                                AccessDeniedException accessDeniedException) throws IOException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");

    response.getWriter().write(RestBean.forbidden(accessDeniedException.getMessage()).asJsonString());
}
```

RestBean：

```java
//登录但没权限
public static <T> RestBean<T> forbidden(String message){
    return failure(403,message);
}
```





### 3 结构化

#### 3.1 必要依赖

##### fastjson

 将字符串转换成json的工具类

```xml
<!-- 字符串转换成json -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.44</version>
</dependency>

```



##### java-jwt

```xml
<!-- java-jwt -->
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.4.0</version>
</dependency>
```



##### redis

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```





#### 3.2 config配置包

config

- `SecurityConfiguration `：security配置类
- 



#### 3.3 entity实体包

entity

- `RestBean `接收信息的实体类
- 



#### 3.4 service层



#### 3.5 mapper层



#### 3.6 utils工具包

- 



### 4 jwt令牌

配置好springsecurity之后，我们的登录就没问题了，但我们现在用的是token

登录之后，要给用户发令牌，否则后面的请求就无法通过了

#### 4.1 如何发令牌？

先导入java-jwt依赖

再创建一个处理jwt令牌的工具类并注册bean

```java
@Component
public class JwtUtils {

}
```



给jwt令牌塞一些用户的信息：id、用户权限、角色等

当我们拿到这个令牌，就知道了当前访问的用户是谁？权限是什么等等

因为是登录成功时颁发的jwt令牌，所以我们先来到处理登录成功的配置方法`onAuthenticationSuccess`

```java
public void onAuthenticationSuccess(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");
    //拿到用户的详细信息
    User user = (User) authentication.getPrincipal();

    response.getWriter().write(RestBean.success().asJsonString());
}
```

创建令牌的方法

```java
@Component
public class JwtUtils {

    //取一下配置文件配置好的密钥
    @Value("${spring.security.jwt.key}")
    String key;

    //从spring配置中取expire值作为过期时间 临时的7天之后要做续签
    @Value("${spring.security.jwt.expire}")
    int expire;



    public String createJwt(UserDetails details,int id,String username){  //从userDetails来获取用户的信息
        //生成用户加密的算法
        Algorithm algorithm = Algorithm.HMAC256(key);   //加载密钥

        Date expire = this.expireTime();    //获取过期时间值

        return JWT
                .create()   //创建
                .withClaim("id", id)   //userDetails里面没有用户的id，只有用户的名字，所以需要单独加进来加上形参 id
                .withClaim("name", username) //我们是通过用户名/邮箱登录的，所以userDetails有可能是邮箱，不太准确同上
                //details.getAuthorities()是一个list形式，我们要通过GrantedAuthority的方法把它变成string类型的权限
                .withClaim("authorities",details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())
                .withExpiresAt(expire)    //过期时间
                .withIssuedAt(new Date())   //现在的token的颁发时间
                .sign(algorithm);   //用算法签名得到lwt令牌
    }

    //过期时间
    private Date expireTime(){
        //Calendar提供了一个日历的功能
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.HOUR,expire*24);   //加载过期时间值

        return calendar.getTime();
    }

}
```

创建好令牌，令牌返回给用户，这样用户就可以拿着令牌来访问其他接口了

```java
@Resource
JwtUtils jwtUtils;

public void onAuthenticationSuccess(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");
    //拿到用户的详细信息
    User user = (User) authentication.getPrincipal();
    //给用户塞一个令牌
    String token = jwtUtils.createJwt(user, 1, "林桑");

    response.getWriter().write(RestBean.success(token).asJsonString());
}
```

测试：登陆成功后，查看数据是否是这个token令牌

![image-20231228213348381](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228213348381.png)

确实有jwt的token



#### 4.2 返回其他信息

token返回给客户端之后，客户端除了拿到了token之后，还会记录一些信息：当前登陆的用户名、过期时间、用户角色等

所以，服务端返回的时候不仅要返回token还要把这些信息返回个客户端，虽然说token中本来就有这些数据但让客户端去解析有点麻烦

我们需要把这些返回的信息封装好

我分别创建与数据库交互的包和与前端交互的包  dto、vo

vo是视图相关的，肯定有request、response



```java
/**
 * @author jocularchao
 * @date 2023-12-28 22:30
 * @description 封装返回给客户端的用户的详细信息
 */
@Data
public class AuthorizeVO {

    String username;    //用户名
    String role;        //角色
    String token;       //token
    Date expire;        //过期时间


}
```





```java
public void onAuthenticationSuccess(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");
    //拿到用户的详细信息
    User user = (User) authentication.getPrincipal();
    //给用户塞一个令牌
    String token = jwtUtils.createJwt(user, 1, "林桑");
    //封装用户信息，用于返回给客户端
    AuthorizeVO vo = new AuthorizeVO();
    vo.setExpire(jwtUtils.expireTime());
    vo.setRole("");
    vo.setToken(token);
    vo.setUsername(user.getUsername());

    response.getWriter().write(RestBean.success(vo).asJsonString());
}
```

![image-20231228223842270](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228223842270.png)

虽然有很多问题：

role没有确定--------------------

username 是登陆的用户名但和自己定义的不一样------------对接数据库后解决

expire 这里重新调用了 是不是说明新生成了一个过期时间呢？

我们之后解决



#### 4.3 jwt请求头校验

​	jwt用户再发起请求的时候，请求头里面会带有我们刚刚颁发的token，通过过滤器的机制把jwt 的token解析出来通过验证，用户就可以访问其他接口了

​	security内部有一套过滤器链，它内部的一个过滤机制，我们需要把自己写的过滤器加到它的过滤器链里面，以此把我们的验证流程加入到它本身的机制里面

先创建解析jwt的工具方法在JwtUtils中：

```java
//解析jwt
public DecodedJWT resolveJwt(String headerToken){
    String token = this.convertToken(headerToken);
    if (token == null)
        return null;
    //token解析的算法 与生成时的算法一致
    Algorithm algorithm = Algorithm.HMAC256(key);
    JWTVerifier  jwtVerifier = JWT.require(algorithm).build();

    try {
        //验证当前的jwt是否合法，就是看是否被用户篡改过，若是篡改过就会抛一个验证异常的运行时异常
        DecodedJWT verifier = jwtVerifier.verify(token);
        //查看jwt令牌是否过期了
        Date expires = verifier.getExpiresAt();

        return new Date().after(expires) ? null:verifier;
    }catch (JWTVerificationException e){
        return null;
    }


}

//Authorization中带的是Bear token 所以我们要判断一下是否为这个格式，并把token剪切出来
private String convertToken(String headerToken){
    if (headerToken == null || !headerToken.startsWith("Bearer "))
        return null;
    return headerToken.substring(7);

}
```

准备专门用于解析用户的id值

```java
//解析id值
public Integer toId(DecodedJWT jwt){
    Map<String, Claim> claims = jwt.getClaims();

    return claims.get("id").asInt();
}
```

创建filter包做过滤器JwtAuthorizeFilter：

```java
@Component
public class JwtAuthorizeFilter extends OncePerRequestFilter {  //一次请求执行一次的普通过滤器

    //注入
    @Resource
    JwtUtils jwtUtils;

    //验证逻辑
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        //从请求头里面读出来Authorization
        //header里面有一个Authorization的请求头，它携带"Bearer token"的字符串
        String authorization = request.getHeader("Authorization");
        //利用工具类解析请求头携带的token
        DecodedJWT jwt = jwtUtils.resolveJwt(authorization);
        if (jwt!=null){
            //利用工具类解析jwt为用户信息
            UserDetails details = jwtUtils.toUser(jwt);
            //这个token是spring security内部的一个token
            UsernamePasswordAuthenticationToken authenticationToken = new
                    UsernamePasswordAuthenticationToken(details,null,details.getAuthorities());

            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            //直接把验证信息往security context里面丢进去,验证就通过了
            SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            //工具类解析id值
            request.setAttribute("id", jwtUtils.toId(jwt));
        }
        filterChain.doFilter(request,response);


    }
}
```

创建测试控制类

```java
@RestController
@RequestMapping("/api/test")
public class TestController {

    @GetMapping("/hello")
    public String test(){
        return "hello";
    }
}
```

security configuration：

```java
//添加自定义的过滤器
.addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)
```

测试、拿到token值

![image-20231230182626337](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231230182626337.png)

我们正常什么都不带测试 test/hello接口会提示请登录的页面

![image-20231230182912818](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231230182912818.png)

新建测试接口，对请求头进行测试，把token放入进来

![image-20231230183422892](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231230183422892.png)

请求其他接口成功了



#### 4.4 jwt退出登录

在退出登录后，jwt令牌如果直接丢弃是不行的，这是一个安全隐患，因为其他人可能会用到这个令牌

我们需要把它封禁掉，拉入黑名单，要把这个令牌失效

我们采用黑名单的形式 用redis来实现

导入redis依赖后，创建让令牌失效的方法

`JwtUtils`

```java
@Resource
    StringRedisTemplate template;



    //创建令牌
    public String createJwt(UserDetails details,int id,String username){  //从userDetails来获取用户的信息
        //生成用户加密的算法
        Algorithm algorithm = Algorithm.HMAC256(key);   //加载密钥

        Date expire = this.expireTime();    //获取过期时间值

        return JWT
                .create()   //创建
                .withJWTId(UUID.randomUUID().toString())    //生成随机id便于在销毁jwt时处理
                .withClaim("id", id)   //userDetails里面没有用户的id，只有用户的名字，所以需要单独加进来加上形参 id
                .withClaim("name", username) //我们是通过用户名/邮箱登录的，所以userDetails有可能是邮箱，不太准确同上
                //details.getAuthorities()是一个list形式，我们要通过GrantedAuthority的方法把它变成string类型的权限
                .withClaim("authorities",details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())
                .withExpiresAt(expire)    //过期时间
                .withIssuedAt(new Date())   //现在的token的颁发时间
                .sign(algorithm);   //用算法签名得到lwt令牌
    }

    //销毁令牌
    public boolean invalidateJwt(String headerToken){
        String token = this.convertToken(headerToken);
        if (token == null)  return false;
        Algorithm algorithm = Algorithm.HMAC256(key);
        JWTVerifier  jwtVerifier = JWT.require(algorithm).build();

        try {
            DecodedJWT jwt = jwtVerifier.verify(token);
            String id = jwt.getId();
            return deleteToken(id,jwt.getExpiresAt());

        }catch (JWTVerificationException e){
            return false;
        }

    }

    //删除令牌
    private boolean deleteToken(String uuid,Date time){
        if (this.isInvalidToken(uuid)){
            return false;
        }
        Date now = new Date();
        long expire = Math.max(time.getTime() - now.getTime(),0);   //如果已经过期了，那么值就为负值，不能给到token，就用0替代

        template.opsForValue().set(uuid,"",expire, TimeUnit.MILLISECONDS);
        return true;

    }

    //判断令牌是否过期
    private boolean isInvalidToken(String uuid){
        //查询uuid是否在黑名单列表中
        return Boolean.TRUE.equals(template.hasKey(Const.JWT_BLACK_LIST + uuid));
    }
    
    public DecodedJWT resolveJwt(String headerToken){
        String token = this.convertToken(headerToken);
        if (token == null)
            return null;
        //token解析的算法 与生成时的算法一致
        Algorithm algorithm = Algorithm.HMAC256(key);
        JWTVerifier  jwtVerifier = JWT.require(algorithm).build();

        try {
            //验证当前的jwt是否合法，就是看是否被用户篡改过，若是篡改过就会抛一个验证异常的运行时异常
            DecodedJWT verifier = jwtVerifier.verify(token);
            //查看jwt令牌是否失效
            if (this.isInvalidToken(verifier.getId())){
                return null;
            }
            //查看jwt令牌是否过期了
            Date expires = verifier.getExpiresAt();

            return new Date().after(expires) ? null:verifier;
        }catch (JWTVerificationException e){
            return null;
        }


    }
```

再配置登出的处理

```java
//登出成功的处理
//虽然登出成功和登陆成功的参数一样，但由于我们在登出的时候会写一个让jwt失效的功能，所以不能写在一起
public void onLogoutSuccess(HttpServletRequest request,
                            HttpServletResponse response,
                            Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");
    //把writer 便于之后的判断
    PrintWriter writer = response.getWriter();

    String authorization = request.getHeader("Authorization");
    if (jwtUtils.invalidateJwt(authorization)){
        writer.write(RestBean.success().asJsonString());
    }else {
        writer.write(RestBean.failure(400,"退出登录失败").asJsonString());
    }
}
```

 注意删除掉jdbc相关的依赖，我们之后再配置

![image-20240103182620645](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103182620645.png)

我们获取到token值，再用于接口测试

![image-20240103182801880](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103182801880.png)

我们新建测试接口，logout，并带authorization的请求头访问 logout













​	









### 5 对接数据库

#### 5.0 数据库设计

##### 建库

创建community的数据库

![image-20231212183435823](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212183435823.png)

##### 建表

```sql
create table `db_account` (
  `id` int not null auto_increment,
  `username` varchar(255) default null,
  `password` varchar(255) default null,
  `email` varchar(255) default null,
  `role` varchar(255) default null,
  `register_time` datetime default null,
  primary key (`id`),
  unique key `unique_email` (`email`),
  unique key `unique_username` (`username`)
) engine=innodb auto_increment=4 default charset=utf8mb4;
```



##### 生成密码

在test类中加密“123456”的密码

```java
@Test
void contextLoads() {
    BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    //$2a$10$RQ4LuWr5hL73VDxztxJGu.lAwCTHustBif5sKiKK9866u.1m1LUaS
    System.out.println(encoder.encode("123456"));
}
```



##### 存一条数据

把admin的用户名和加密后的密码存入一条

![](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103205502263.png)

##### 规范

用户名和邮箱必须是唯一的：

![image-20231213173807593](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213173807593.png)

![image-20231213173844273](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213173844273.png)



用户名不能写成邮箱形式与其他用户邮箱冲突：







#### 5.1 创建service层和mapper层

导入依赖

```xml
<!--数据源-->
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.2.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.5</version>
</dependency>
```

![image-20231213172942382](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213172942382-1702459783240-1.png)

#### 5.2 创建account实体类

```java
@Data
@TableName("db_account")
@AllArgsConstructor
public class Account {

    @TableId(type = IdType.AUTO)
    Integer id;
    String username;
    String password;
    String email;
    String role;
    Date registerTime;  //注册时间

}
```

#### 5.3 创建AccountMapper

```java
@Mapper
public interface UserMapper {

    //根据用户名或密码找到用户
    @Select("select * from db_account where username = #{text} or email = #{text}")
    Account findAccountByNameOrEmail(String text);

}
```

#### 5.4 创建AccountService类

```java
public interface AccountService extends IService<Account> , UserDetailsService {

    //根据用户名或邮箱查找用户
    Account findAccountByNameOrEmail(String text);
}
```

```java
@Service
public class AccountServiceImpl extends ServiceImpl<AccountMapper, Account> implements AccountService {


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = this.findAccountByNameOrEmail(username);
        if (account == null){
            throw new UsernameNotFoundException("用户名或邮箱错误");
        }


        return User
                .withUsername(username) //登录的是邮箱那么返回的也是邮箱
                .password(account.getPassword())
                .roles(account.getRole())
                .build();
    }


    public Account findAccountByNameOrEmail(String text){

        return this.query()
                .eq("username",text).or()
                .eq("email",text)
                .one();
    }
}
```



#### 5.5 配置数据源

```java
 
```



#### 5.6 配置加密器

创建`WebConfiguration`类存放密码加密器





#### 5.7 启动测试

![](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103214019261.png)

后台不再生成密码

以前的登录也有问题了，只能用数据库保存的用户来登录了

![](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103213931513.png)

![image-20240103214418958](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240103214418958.png)





#### 5.8 完善登录成功后用户信息的处理

在SecurityConfiguration类中

因为要从数据库中取数据所以就会有两种方法：

- 创建threadlocal，再从threadlocal里面取数据
- 再一次查询数据库

我们为了代码简单方便就使用 再次查询数据库

```java
    //再次查询数据库
    @Resource
    AccountService service;

	public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        //配置编码
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        //拿到用户的详细信息
        User user = (User) authentication.getPrincipal();   //这里应该自己封装一个userdetails 不用springsecurity提供的user实现
        //根据拿到的用户 再次查询数据库进行验证并获得实体类用户信息
        Account account = service.findAccountByNameOrEmail(user.getUsername());
        //给用户塞一个令牌
        String token = jwtUtils.createJwt(user, account.getId(), account.getUsername());
        //封装用户信息，用于返回给客户端
        AuthorizeVO vo = new AuthorizeVO();
        vo.setExpire(jwtUtils.expireTime());
        vo.setRole(account.getRole());
        vo.setToken(token);
        vo.setUsername(account.getUsername());

        response.getWriter().write(RestBean.success(vo).asJsonString());
    }
```

![image-20240104140115671](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240104140115671.png)



##### 5.8.1 还没完？对 我们要做小小的优化，在dto返回vo的信息，除了单纯的set get 我们还可以利用api BeanUtils的方法来拷贝

```java
//根据拿到的用户 再次查询数据库进行验证并获得实体类用户信息
Account account = service.findAccountByNameOrEmail(user.getUsername());
//给用户塞一个令牌
String token = jwtUtils.createJwt(user, account.getId(), account.getUsername());
//封装用户信息，用于返回给客户端,把dto的数据 返回给vo，再由vo返回给客户端
AuthorizeVO vo = new AuthorizeVO();
BeanUtils.copyProperties(account,vo);
vo.setExpire(jwtUtils.expireTime());
//vo.setRole(account.getRole());
vo.setToken(token);
//vo.setUsername(account.getUsername());

response.getWriter().write(RestBean.success(vo).asJsonString());
```



##### 5.8.2 再优化--创建自定义拷贝工具利用反射机制进行拷贝

创建BaseData 接口，来自定义拷贝方法

```java
public interface BaseData {
    
    default <V>V asViewObject(Class<V> clazz, Consumer<V> consumer){
        V v = this.asViewObject(clazz);
        consumer.accept(v);
        return v;
    }


    default <V>V asViewObject(Class<V> clazz){

        try {
            //把全部字段取出来
            Field[] declaredFields = clazz.getDeclaredFields();

            //获得构造器
            Constructor<V> constructor = clazz.getConstructor();
            //获取任意类型的vo对象
            V v = constructor.newInstance();
            for (Field field : declaredFields) convert(field,v);
            return v;


        }catch (ReflectiveOperationException exception){//有可能出现反射异常
            throw new RuntimeException(exception.getMessage());
        }


    }
    private void convert(Field field,Object vo){
        try {
            Field source = this.getClass().getDeclaredField(field.getName());

            field.setAccessible(true);
            source.setAccessible(true);

            field.set(vo,source.get(this));
        } catch (IllegalAccessException | NoSuchFieldException ignored) {}

    }


}
```

account实现该接口完成返回AuthorizeVO类

![image-20240104180139800](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240104180139800.png)

```java
public void onAuthenticationSuccess(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");
    //拿到用户的详细信息
    User user = (User) authentication.getPrincipal();   //这里应该自己封装一个userdetails 不用springsecurity提供的user实现
    //根据拿到的用户 再次查询数据库进行验证并获得实体类用户信息
    Account account = service.findAccountByNameOrEmail(user.getUsername());
    //给用户塞一个令牌
    String token = jwtUtils.createJwt(user, account.getId(), account.getUsername());
    //封装用户信息，用于返回给客户端,把dto的数据 返回给vo，再由vo返回给客户端
    //AuthorizeVO vo = new AuthorizeVO();
    //1 拷贝信息
    //BeanUtils.copyProperties(account,vo);
    //2 自定义拷贝方法
    AuthorizeVO vo = account.asViewObject(AuthorizeVO.class,v->{
            v.setExpire(jwtUtils.expireTime());
            v.setToken(token);
        });

    response.getWriter().write(RestBean.success(vo).asJsonString());
}
```

![image-20240104175943757](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240104175943757.png)









配置好没问题了，我们来丰富前端页面和封装axios



### 6 解决跨域问题

springboot安全问题导致

跨域问题不解决就无法调用前端的接口

创建专门用于跨域的过滤器

```java
@Component
//spring security的过滤器链 它的优先级很高 默认-100，而跨域的过滤器 包括限流等功能 是要在它之前的
@Order(Const.ORDER_CORS)
public class CorsFilter extends HttpFilter {

    @Override
    protected void doFilter(HttpServletRequest request,
                            HttpServletResponse response,
                            FilterChain chain) throws IOException, ServletException {
        this.addCorsHeader(request,response);
        //正常放行
        chain.doFilter(request,response);
    }

    //在响应头添加跨域信息
    private void addCorsHeader(HttpServletRequest request,
                               HttpServletResponse response){

        //允许哪些地址跨域访问        这个Origin是网络请求中前端的地址在浏览器的network中可以查到
        response.addHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));

        //添加允许的一些方法
        response.addHeader("Access-Control-Allow-Methods","GET,POST,PUT,DELETE,OPTIONS");
        //
        response.addHeader("Access-Control-Allow-Headers","Authorization, Content-Type");
    }
}
```

CorsFilter :

```java
@Component
//spring security的过滤器链 它的优先级很高 默认-100，而跨域的过滤器 包括限流等功能 是要在它之前的
@Order(Const.ORDER_CORS)
public class CorsFilter {

}
```

由于有优先级问题，我们可以额外配置一下默认的

```yml
spring:
  security:
    filter:
      order: -100
```

测试请求成功

![image-20240113131520991](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240113131520991.png)

优化安全问题：





解决跨域问题后，我们登录并检查[浏览器token值留存问题](####7.3 检查浏览器token值留存)



### 7 登出成功的handler

```java
		//配置登出接口
        .logout()
        .logoutUrl("/api/auth/logout")
        //配置登出成功的处理----使用登录成功写的处理方法
        .logoutSuccessHandler(this::onAuthenticationSuccess)
        .and()
....
//登录成功
//登出成功
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        //设置编码格式
        response.setCharacterEncoding("utf-8");
        //通过请求url的结尾来判断登录还是登出
        if (request.getRequestURI().endsWith("login"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("登录成功")));
        else if (request.getRequestURI().endsWith("logout"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("登出成功")));
    }
```

![image-20231216132529358](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216132529358.png)



### 8 记住我

用户点了记住我，才能记住密码，没点重新登录

remember不可能一直存在内存中，所以我们用jdbc持久化地去存储remember的token值，以达到保存remember的作用



```java
    
			//配置登出成功的处理----使用登录成功写的处理方法
            .logoutSuccessHandler(this::onAuthenticationSuccess)
            .and()
            //配置记住我
            .rememberMe()
            //配置参数值就为remember
            .rememberMeParameter("remember")
            .tokenRepository(tokenRepository)
            //设置token的过期时间 按秒算的
            .tokenValiditySeconds(3600*24*7)
            .and()
            //暂时关闭csrf校验
.....
	//持久化token仓库用于存remember
    @Bean
    public PersistentTokenRepository tokenRepository(){
        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
        //设置数据源
        jdbcTokenRepository.setDataSource(dataSource);
        //初始化持久化仓库的表,只需要第一次运行生成这个表，以后运行改成false，不创建就好了
        //jdbcTokenRepository.setCreateTableOnStartup(true);
        jdbcTokenRepository.setCreateTableOnStartup(false);
        return jdbcTokenRepository;
    }
```

当点击记住我登录成功后，数据库就会创建一个专门存token值的表，用作remember

![image-20231216181425142](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216181425142.png)

![image-20231216182213618](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216182213618.png)

记住我解决完后，我们去前端编写注册功能



### 9 邮箱验证功能



#### 9.1 创建邮箱校验相关类

##### 9.1.1 重新创建权限校验的服务

以前的服务类，改成服务实现类

```java
public interface AuthorizeService extends UserDetailsService {


	//邮箱校验
    boolean sendValidateEmail(String email);
}
```

##### 9.1.2 权限校验的服务实现类

```java
@Service
public class AuthorizeServiceImpl implements AuthorizeService {   //实现UserDetailsService接口从数据库中取东西

    //注入mapper
    @Resource
    UserMapper mapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //
        if (username == null){
            throw new UsernameNotFoundException("用户名不能为空");
        }
        Account account = mapper.findAccountByNameOrEmail(username);
        //获取的account用户对象，如果为空则说明，没有从数据库中取到该对象，说明用户名或密码错误
        if (account == null){
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        return User
                .withUsername(account.getUsername())
                .password(account.getPassword())
                .roles("user")
                .build();
    }


    @Override
    public boolean sendValidateEmail(String email) {
        /*
        1、生成验证码
        2、把邮箱和对应验证码放到redis中（过期时间三分钟，若剩余时间低于2分钟就可以重新发送邮件一次，重复此操作！）
        3、发送验证码到指定邮箱中
        4、若发送失败，则把redis里面刚刚插入的键值对删除
        5、若发送成功，也取出对应的验证码与前端输入的验证码进行比较，看是否一致
        */
        return false;
    }



}
```

##### 9.1.3 权限校验的控制类

`AuthorizeController.java`

```java
@RestController
//权限校验相关的映射
@RequestMapping("/api/auth")
public class AuthorizeController {

    @Resource
    AuthorizeService service;

    @PostMapping("/valid-mail")
    public RestBean<String> validateEmail(@RequestParam("email") String email) {
        if (service.sendValidateEmail(email)){
            return RestBean.success("邮件已发送，请注意查收");
        }else {
            return RestBean.failure(400,"邮件发送失败，请联系管理员");
        }
    }
}
```



#### 9.2 补充邮箱校验的具体功能





##### 9.2.2 spring-validation做安全校验

做进一步的安全校验，防止类似apipost或其他情况恶意攻击服务器，我们引入spring-validation，他会在请求到来时对接口进行验证



验证相关的请求全部要放行，不然就会被拦截





### 10





## 前端

### 1 创建项目

#### 1.1 webstorm创建create-vue项目

![image-20231212115824321](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115824321.png)

#### 1.2 更新并测试运行

![image-20231212115925412](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115925412.png)

#### 1.3 清理干净项目

```javascript
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

```vue
<script setup>

</script>

<template>

</template>

<style scoped>

</style>
```

![image-20231212120257781](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212120257781-1702353778372-1.png)



#### 1.4 必要依赖

开启科学上网，防止网络问题

##### 1.4.1 路由router



`npm i vue-router`



##### 1.4.2 element-ui



`npm install element-plus --save`

###### 按需导入

安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件

`npm install -D unplugin-vue-components unplugin-auto-import`



在vite配置文件中配置

```javascript
import {fileURLToPath, URL} from 'node:url'

import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue(),
        AutoImport({
            resolvers: [ElementPlusResolver()],
        }),
        Components({
            resolvers: [ElementPlusResolver()],
        }),
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('./src', import.meta.url))
        }
    }
})
```



###### 完整导入

按需导入后，我发现elmessage不正常显示，所以我又进行了完整导入

在mian.js中

```js
import 'element-plus/dist/index.css'
import ElementPlus from 'element-plus'

//使用element完整导入
app.use(ElementPlus)
```

消息正常显示了

![image-20231216122949243](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216122949243.png)



##### 1.4.3 axios

`npm install axios`

`npm install vue-axios`



#### 1.5 结构初始化



##### 1.5.1 views视图

- 


##### 1.5.2 component 组件

- 


##### 1.5.3 router路由

- 


##### 1.5.4 stores

- 


##### 1.5.5 assets

- 





### 2 登陆功能

#### 2.1 先写好布局

直接在app.vue组件中编写

```vue
<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">

    </div>
    <!--右半边 固定宽度-->
    <div style="width: 300px;background-color: aquamarine">

    </div>
  </div>
</template>
```

![image-20231213183319305](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213183319305.png)

在最外层`index.html`中设置外边距为0去掉空白

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
    <style>
        body{
            margin: 0;
        }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

![image-20231213183637611](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213183637611.png)



#### 2.2 登录界面

```vue
<script setup>
//导入element的图标组件User、lock
import {User} from '@element-plus/icons-vue'
import {Lock} from '@element-plus/icons-vue'
</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/rain.jpg"/>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <div style="text-align: center;margin: 0 20px">
        <div style="margin-top: 150px">
          <div style="font-size: 25px">登录</div>
          <div style="font-size: 14px;color: darkgray">在进入系统前请先输入用户名和密码进行登录</div>
        </div>

        <div style="margin-top: 50px">
          <!--用户名-->
          <el-input type="text" placeholder="用户名/邮箱">
            <!--使用element的用户图标-->
            <template #prefix>
              <el-icon><User /></el-icon>
            </template>
          </el-input>
          <!--密码-->
          <el-input type="password" style="margin-top: 13px" placeholder="密码">
            <template #prefix>
              <el-icon><Lock /></el-icon>
            </template>
          </el-input>
        </div>
        <!--左右布局：记住我和忘记密码-->
        <el-row>
          <el-col :span="12" style="text-align: left">
            <el-checkbox label="记住我" v-model="checked1" />
          </el-col>
          <el-col :span="12" style="text-align: right">
            <el-link>忘记密码?</el-link>
          </el-col>
        </el-row>
        <!--登录按钮-->
        <div style="margin-top: 25px;margin-top: 40px">
          <el-button style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
        </div>
        <!--提示注册-->
        <el-divider>
          <span style="color: gray;font-size: 13px">没有账户？</span>
        </el-divider>
        <!--注册按钮-->
        <el-button style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
      </div>
    </div>
  </div>
</template>

<style scoped>

</style>
```

![image-20231214181346023](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214181346023.png)



### 3 配置

#### 3.1 路由配置

登录界面写完就来配置路由

首先我们要配置两层路由

- 整个大框架的路由
- 页面的路由

##### 3.1.1 划分页面

把主页面的登录内容复制到视图目录中的欢迎视图中

![image-20231214182646468](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214182646468.png)

再把单独的登录用的表单移动到登录界面中完成划分

![image-20231214183040547](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214183040547.png)

再把空余部分用<router-view />填充

###### App.vue

```vue
<script setup>

</script>

<template>
  <router-view />
</template>

<style scoped>

</style>
```

###### WelcomeView.vue

```vue
<script setup>


</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/rain.jpg"/>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <router-view />
    </div>
  </div>
</template>

<style scoped>

</style>
```

###### LoginPage.vue

```vue
<script setup>
//导入element的图标组件User、lock
import {Lock, User} from "@element-plus/icons-vue";

</script>

<template>
  <div style="text-align: center;margin: 0 20px">
    <div style="margin-top: 150px">
      <div style="font-size: 25px">登录</div>
      <div style="font-size: 14px;color: darkgray">在进入系统前请先输入用户名和密码进行登录</div>
    </div>

    <div style="margin-top: 50px">
      <!--用户名-->
      <el-input type="text" placeholder="用户名/邮箱">
        <!--使用element的用户图标-->
        <template #prefix>
          <el-icon>
            <User/>
          </el-icon>
        </template>
      </el-input>
      <!--密码-->
      <el-input type="password" style="margin-top: 13px" placeholder="密码">
        <template #prefix>
          <el-icon>
            <Lock/>
          </el-icon>
        </template>
      </el-input>
    </div>
    <!--左右布局：记住我和忘记密码-->
    <el-row>
      <el-col :span="12" style="text-align: left">
        <el-checkbox label="记住我" v-model="checked1"/>
      </el-col>
      <el-col :span="12" style="text-align: right">
        <el-link>忘记密码?</el-link>
      </el-col>
    </el-row>
    <!--登录按钮-->
    <div style="margin-top: 25px;margin-top: 40px">
      <el-button style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
    </div>
    <!--提示注册-->
    <el-divider>
      <span style="color: gray;font-size: 13px">没有账户？</span>
    </el-divider>
    <!--注册按钮-->
    <el-button style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
  </div>
</template>

<style scoped>

</style>
```



##### 3.1.2 路由配置文件

创建router文件夹和router主配置文件

![image-20231214183756138](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214183756138.png)

编写路由配置

```js
import {createRouter, createWebHistory} from "vue-router";

const router = createRouter({
    history:createWebHistory(import.meta.env.BASE_URL),
    routes:[
        
    ]
})

//导出路由
export default router;
```

主配置文件`main.js`调用上面配置好的router

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from "@/router/index.js";

const app = createApp(App)

//使用路由
app.use(router)

app.mount('#app')
```



##### 3.1.3 编写路由

在router/index.js中编写路由

```js
routes:[
    {
        path:'/',       //路由地址
        name:'welcome', //路由名
        component:()=>import('@/views/WelcomeView.vue'),    //路由所引用的组件
        //子路由
        children:[
            {
                path:'',
                name:'welcome-login',
                component:()=>import('@/components/welcome/LoginPage.vue')
            }
        ]
    }
]
```

##### 3.1.4 主页路由

与welcome路由并列

```js
,
{
    path:'/index',
    name:'index',
    component:()=>import('@/views/IndexView.vue')
}
```

测试

![image-20231214202717243](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214202717243.png)



##### 3.1.5 注册路由

```js
//子路由
children:[
    //登录
    {
        path:'',
        name:'welcome-login',
        component:()=>import('@/components/welcome/LoginPage.vue')
    },
    //注册
    {
        path:'register',
        name:'welcome-register',
        component:()=>import('@/components/welcome/RegisterPage.vue')
    }
```







### 4 主题内容

在welcome.vue中的左半边图片上加上主题内容

```vue
<script setup>


</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/mao3.jpg"/>
    </div>
    <!--设置主题内容：绝对定位以便在图片上写内容 -->
    <div class="welcome-title">
      <div>模板</div>
      <p>学习登陆注册模板</p>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <router-view/>
    </div>
  </div>
</template>

<style scoped>
.welcome-title {
  position: absolute;
  left: 40px;
  bottom: 45px;

}

.welcome-title div {
  color: white;
  font-size: 60px;
  font-weight: bold;
  text-shadow: 0 1px 8px blanchedalmond;
}
.welcome-title p {
  color: white;
  top: 10px;
}
</style>
```

![image-20231214201618439](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214201618439.png)





### 5 主页

简单写一下，做个样子

创建IndexView.vue视图组件，并配置路由测试

```vue
<script setup>

</script>

<template>
  <div>welcome to template page</div>
  <!--登出按钮-->
  <div style="margin-top: 10px">
    <!--plain 为el-button的朴素样式-->
    <el-button type="danger" plain>登出</el-button>
  </div>
</template>

<style scoped>

</style>
```



6



### 7 前后端连接

我们安装依赖axios后，利用它来做异步请求工具，动态向后端发送请求完成登录、登出等功能



#### 7.1 统一封装axios

##### 7.1.1 内部使用的get、post

创建net文件夹和index.js

```js
import axios from "axios";
import {ElMessage} from "element-plus";



const authItemName = "access_token";



//token

// token的取出操作
function takeAccessToken() {

    //获得的值就是后端给客户端的data
    const str = localStorage.getItem(authItemName) || sessionStorage.getItem(authItemName);
    // 如果没拿到数据，返回空
    if (!str)   return null;
    // 如果拿到了，解析json值重新赋值给我们的object，并做判断
    const authObj = JSON.parse(str);

    //
    if(authObj.expire<= new Date()){
        //如果日期时间小于当前时间，即过期了，需要我们重新登录，来获取新的token
        deleteAccessToken();
        ElMessage.warning("登录状态已过期，请重新登录");
        return null;
    }

    return authObj.token;
}

//token的删除操作
function deleteAccessToken() {

    localStorage.removeItem(authItemName);

    sessionStorage.removeItem(authItemName);
}


// token的保存操作
// 为什么要保存,token有什么用?我们后续的请求都会用token去进行一个校验,它会写在这个请求头里面,存起来给服务端,服务端才可以解析,
// 所以说请求成功之后,登陆成功之后,收到这个请求头,我们需要把token存起来用
/*
    token       token
    remember    记住我
    expire      token的过期时间  下次我们再使用这个token的时候发现已经超过了token的过期时间,那这个token就不能用了,请求就无意义
*/
function storeAccessToken(token, remember, expire) {
    // 把token expire信息,封装成实体对象
    // 当然还有很多其他方式把token保存到本地...
    const authObj = {token: token, expire: expire}
    // local storage  一直存储  或   session storage     只针对对话
    // 到底用哪个?我们用remember来判断    如果我们勾选了 remember  就  local storage,如果不勾选  session storage
    // authObj转成字符串
    const str = JSON.stringify(authObj);
    if (remember)
        localStorage.setItem(authItemName,str);
    else
        sessionStorage.setItem(authItemName,str);

}



// 默认的失败的回调函数
/*
    message     失败的信息
*/
const defaultFailure = (message, code, url) => {
    // 控制台发出警告,并把一些信息打印出来
    console.warn(`请求地址: ${url}, 状态码: ${code}, 错误信息:${message}`)

    // 用element的接口: ElMessage来弹一个弹窗,打印失败信息
    ElMessage.warning(message)
}

//错误回调函数
const defaultError = (err) => {
    // 控制台发出错误,并把一些信息打印出来
    console.error(err)

    // 用element的接口: ElMessage来弹一个弹窗,打印错误信息
    ElMessage.warning('发生了错误,请联系管理员')
}


//内部使用

// 内部使用的post请求
/*
    url     地址
    data    数据
    header  请求头
    success 请求成功的回调函数
    failure 请求失败的回调函数
    error   请求错误的回调函数
*/
function internalPost(url, data, header, success, failure, error = defaultError) {
    // 我们用axios的原生post请求来尝试一下
    // 这里请求头header->headers放入配置里面
    // then就是我们去请求的数据,请求成功之后得到的一个处理,请求成功后,把data解出来({data})=>{}
    // 因为我们后端做了统一,返回的数据都是JSON的格式,并且都是通过返回我们的code来表示是否成功
    axios.post(url, data, {headers: header}).then(({data}) => {
        // code为200 成功
        if (data.code === 200) {
            success(data.data)
        } else { //失败,调用失败的回调函数
            failure(data.message, data.code, url)
        }
    }).catch(err => error(err))      //错误!!
}


// 内部使用的get请求
function internalGet(url, header, success, failure, error = defaultError) {
    axios.get(url, {headers: header}).then(({data}) => {    //回调函数 调用的data是后端传来的data、message、code的集合
        if (data.code === 200) {
            success(data.data)
        } else {
            failure(data.message, data.code, url)
        }
    }).catch(err => error(err))
}

function get(url,success,failure=defaultFailure) {
    internalGet(url,accessHeader(),success,failure);
}

function post(url,data,success,failure=defaultFailure) {
    internalPost(url,data,accessHeader(),success,failure);
}

//内部使用的获取请求头
function accessHeader() {
    const token = takeAccessToken();
    return token?{
        'Authorization': `Bearer ${takeAccessToken()}`
    }:{}
}
```

封装好方法，配置连接后端服务器

在main.js中

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from "@/router/index.js";
import axios from "axios";

const app = createApp(App)

//使用路由
app.use(router)
//配置连接后端服务器
axios.defaults.baseURL = 'http://localhost:8080'

app.mount('#app')
```



##### 7.1.2 外部开放的接口供前端页面调用

可以配和后面的登录登出的前端页面功能一起看

net/index.js

```js
// 外部开放给其他人用的post

// login
function login(username, password, remember, success, failure = defaultFailure) {
    internalPost('/api/auth/login', {
        username: username,
        password: password
    }, {        //因为axios默认是以JSON的格式去提交数据,spring security只支持表单登录,所以我们只能让它以表单的形式去提交
        //我们需要把它的content-type改一下
        'Content-Type': 'application/x-www-form-urlencoded'
    }, (data) => {//成功的回调
        //登陆成功后，我们要保存token值
        storeAccessToken(data.token,remember,data.expire);
        ElMessage.success(`登陆成功,欢迎${data.username}进入我们系统`)
        success(data)
    },failure);

}

//logout
//我们退出登陆的时候要把jwt令牌也带上，这样系统就知道哪个用户登出了，所以要怎么带上呢？
//我们去写一个内部调用的函数  accessHeader  来获取请求头
function logout(success,failure=defaultFailure) {
    get('/api/auth/logout',()=>{
        deleteAccessToken();
        ElMessage.success('退出登陆成功，欢迎再次使用')
        success()
    },failure)
}

//导出登录接口
export {login, logout};
```





#### 7.2 登陆页面实现登录功能

先进行页面优化中的表单校验显示页面

![image-20240106191044122](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240106191044122.png)

数据绑定

```js
<script setup>
//导入element的图标组件User、lock
import {Lock, User} from "@element-plus/icons-vue";
import {ElMessage} from "element-plus";
import {post} from "@/net/index.js";
import router from "@/router/index.js";
import {reactive} from "vue";

//保存表单的数据
const form = reactive(
    {
      username:'',
      password:'',
      remember:false
    }
)

//用户登录
function userLogin(){
  //表单验证
  formRef.value.validate((valid)=>{
    if (valid){ //验证有效
      login(
          form.username,
          form.password,
          form.remember,
          ()=>{})
    }
  })
}
</script>
```

前端组件绑定

```vue
<el-input v-model="form.username" type="text" placeholder="用户名/邮箱">
...
<el-input v-model="form.password" type="password" style="margin-top: 13px" placeholder="密码">
...
<el-col :span="12" style="text-align: left">
    <el-checkbox label="记住我" v-model="form.remember"/>
</el-col>
...
<!--登录按钮-->
<div style="margin-top: 40px">
  <el-button @click="login()" style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
</div>
```

![image-20240106191601529](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240106191601529.png)

200登录成功了报了跨域请求错误

![image-20240106191725116](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240106191725116.png)

直接登录来测试前端，成功的话走后端，报[跨域问题](###6 解决跨域问题)也走后端

封装好方法并暴露在前端进行数据绑定后，就可以去后端进行使用了！！



#### 7.3 检查浏览器token值留存



解决跨域问题后，记住密码，成功登录，在应用中我们发现有本地存储空间 存着token值和过期时间

![image-20240113132108257](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240113132108257.png)

我们删除掉，不勾选记住密码，再登录，发现会话里有了，并且关掉浏览器重新打开就没有了

![image-20240113132818212](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20240113132818212.png)

完美



#### 7.4 主页的登出功能

在IndexView组件

```js
<script setup>
import {get} from '@/net/index.js'
import {ElMessage} from "element-plus";
import router from "@/router/index.js";
const logout=()=>{
  //调用封装的get方法来访问后端限制的登出映射
  get('/api/auth/logout',(message)=>{
    //成功的话，就提示登出成功
    ElMessage.success('登出成功')
    //跳转到登录页面
    router.push('/')
  })
}
</script>
...
<el-button @click="logout()" type="danger" plain>登出</el-button>
```

测试登出发现302了

![image-20231215224723844](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231215224723844.png)

他给我重定向到login界面了

![image-20231215224929838](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231215224929838.png)

所以这时候，我们应该到后端，配置一下登出成功后的handler





### 8 注册页面

#### 8.1 创建组件并配置

创建RegisterPage.vue放到组件目录中与登录组件平级

![image-20231216182703563](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216182703563.png)

到路由配置中配置注册页面的路由

配置好后，组件绑定路由，并测试

`LoginPage.vue`:

```vue
<!--注册按钮-->
<el-button @click="router.push('/register')" style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
```

右半边空白的，测试成功

![image-20231216183415048](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216183415048.png)





#### 8.2 注册页面展示

- 用户名
- 密码
- 密码确认
- 邮箱验证
- 验证码
- 确定

登陆页面代码做参考，复制过来修改

```vue
<script setup>

import {Lock, User, Message, EditPen} from "@element-plus/icons-vue";
import router from "@/router/index.js";
</script>

<template>
  <div style="text-align: center;margin: 0 25px">
    <div style="margin-top: 100px">
      <div style="font-size: 25px">注册新用户</div>
      <div style="font-size: 14px;color: darkgray">欢迎注册，请在下方填写相关信息</div>
    </div>
    <!--注册表单-->
    <div style="margin-top: 60px">
      <!--用户名-->
      <el-input type="text" placeholder="用户名">
        <template #prefix>
          <el-icon><User/></el-icon>
        </template>
      </el-input>
      <!--密码-->
      <el-input style="margin-top: 11px" type="password" placeholder="密码">
        <template #prefix>
          <el-icon><Lock/></el-icon>
        </template>
      </el-input>
      <!--重复密码-->
      <el-input style="margin-top: 11px" type="password" placeholder="重复密码">
        <template #prefix>
          <el-icon><Lock/></el-icon>
        </template>
      </el-input>

    </div>
    <el-input style="margin-top: 11px" type="email" placeholder="电子邮箱地址">
      <template #prefix>
        <el-icon><Message /></el-icon>
      </template>
    </el-input>
    <!--邮箱验证-->
    <div style="margin-top: 11px">
      <!--布局：不太懂分栏部分，厉害的家人们敬请补充和说明-->
      <el-row>
        <el-col :span="14">
          <el-input type='text' placeholder="请输入电子邮件验证码">
            <template #prefix>
              <el-icon><EditPen /></el-icon>
            </template>
          </el-input>
        </el-col>
        <el-col :span="3"></el-col>
        <el-button type="success" plain>获取验证码</el-button>
      </el-row>
    </div>
    <div style="margin-top: 75px">
      <el-button type="warning" style="width: 270px;border-radius: 3px" plain>立即注册</el-button>
    </div>
    <div style="margin-top: 20px;">
      <!--element有下沉问题，要不就一块下沉要不就上移2px-->
      <!--<el-link disabled>已有帐号？</el-link>&nbsp;<el-link type="primary" :underline="false">立即登录</el-link>-->
      <span style="font-size: 14px;line-height: 15px;color: gray">已有帐号？</span>
      <el-link type="primary" :underline="false" style="translate: 0 -2px" @click="router.push('/')">立即登录</el-link>
    </div>
  </div>
</template>

<style scoped>

</style>
```

测试“立即登录”是否跳转成功

先点注册账号、再点立即登录，成功！

![image-20231216202916478](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216202916478.png)



#### 8.3 数据绑定

```vue
<script setup>

import {Lock, User, Message, EditPen} from "@element-plus/icons-vue";
import router from "@/router/index.js";
import {reactive} from "vue"

//注册表单数据绑定
const form = reactive({
  username:'',
  password:'',
  password_repeat:'',
  email:'',
  code:''
})

</script>
<template>
	<el-input v-model="form.username" type="text" placeholder="用户名">
    ...
    <el-input v-model="form.password" style="margin-top: 11px" type="password" placeholder="密码">
    ...
    ...
</template>
```

可以正常输入了，nice

![image-20231216204942112](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216204942112.png)



#### 8.4 电子邮箱校验

在校验之前，最好一定要进行**[页面优化](###9 页面优化)**，全看完再来

我们如何判断电子邮箱是否可以接收验证码？即判断电子邮箱是否有效

```js
//ref
import {ref} from "vue"
const formRef = ref()
//电子邮箱是否有效  默认无效
const isEmailValid = ref(false)
//如果电子邮箱无效，那就把获取验证码的按钮disable掉

//那什么时候更新呢，我们
const onValidate=(prop,isValid)=>{
  if (prop === 'email'){
    isEmailValid.value = isValid
  }
}

//验证整个表单内容，对整个表单内容进行检查，把方法给到自己注册按钮
const register = ()=>{
  formRef.value.validate((isValid)=>{
    if (isValid){ //都正常

    }else { //有问题
      ElMessage.warning('请完整填写注册表单内容')
    }
  }).then()
}
```

```vue
<el-button type="warning" style="width: 270px;border-radius: 3px" @click="register()" plain>立即注册</el-button>
```



我们后端补充发送邮件后，接着写前端的发送验证码功能







### 9 页面优化



#### 9.1 内置过渡动画

在`WelcomeView.vue`页面组件，添加右半边登录注册转换的过渡动画，保证页面转换更流畅

```html
<!--右半边 固定宽度-->
<div style="width: 400px;background-color: white">
  <transition name="el-fade-in-linear">
    <router-view/>
  </transition>
```



#### 9.2 调整重叠位置

`WelcomeView.vue`:

```vue
<!--右半边 固定宽度-->
<div style="width: 400px;background-color: white;z-index: 1">
  <transition name="el-fade-in-linear">
    <router-view/>
  </transition>
```

保证左半边文字不会覆盖右半边登录注册模块



#### 9.3 控制台`transition`警告

```bash
[Vue Router warn]: <router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <transition>
    <component :is="Component" />
  </transition>
</router-view>
```

按着他的写就行了

在过渡动画位置加上插槽

```vue
<!--设置过渡动画、解决v-slot警告-->
<router-view v-slot="{ Component }">
  <transition mode="out-in" name="el-fade-in-linear">
    <component :is="Component" />
  </transition>
</router-view>
```



#### 9.4 表单校验

前端自己识别一些错误：格式错误、密码重复错误等

我们需要在表单外套一层element-plus给我们提供的表单`el-form  el-form-item`

我们在登录、注册页面分别套一层，并且去掉margin-top

##### 9.4.1 校验规则

我们需要自定义校验规则才能让前端识别错误

用户名可以由中英文字符、数字或它们的混合组成，但不能包含特殊字符

```txt
^[A-Za-z0-9\u4e00-\u9fa5]*$
```

![image-20231216215542980](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216215542980.png)

```js
//校验用户名 username
const validateUsername = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('请输入用户名'))
  }else if (!/^[A-Za-z0-9\u4e00-\u9fa5]*$/.test(value)){//value包含特殊字符，就提示有特殊字符的异常
    callback(new Error('用户名不能包含有特殊字符，只能是中文、英文、数字或它们的混合'))
  }else{
    callback()    //没有问题！
  }
}
//校验密码
const validatePassword = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('密码不能为空！'))
  }else {
    callback()
  }
}
//校验重复密码  password_repeat
const validatePasswordRepeat = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('请重新输入密码'))
  }else if (value!==form.password){  //是否等于表单的password
    callback(new Error('两次输入的密码不一致'))
  }else{
    callback()
  }
}
//自定义rules校验规则
const rules = {
  /*
    username  使用自定义的用户名校验方法，在聚焦或修改时校验，长度：3-11
  */
  username:[
    {validator:validateUsername,trigger:['blur','change']},
    {min:3,max:11,message:'用户名的长度在3~11之间',trigger:['blur','change']}
  ],
  password:[
    {validator:validatePassword,trigger:['blur','change']},
    {min:6,max:20,message:'密码的长度在6~20之间',trigger:['blur','change']}
  ],
  password_repeat:[
    {validator:validatePasswordRepeat,trigger:['blur','change']}
  ],
  email:[
    {required: true, message: '请输入电子邮件地址', trigger: ['blur']},
    {type: 'email', message: '请输入合法的电子邮件地址', trigger: ['blur', 'change']}
  ],
  code:[
    {required: true, message: '请输入获取的验证码', trigger: ['blur']}
  ]
}

```



```js
import {reactive,ref} from "vue";

const formRef = ref()

//校验规则
const rules = {
  username: [
    { required: true, message: '请输入用户名' }
  ],
  password: [
    { required: true, message: '请输入密码'}
  ]
}
```

![image-20231218180256770](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231218180256770.png)



##### 9.4.2 login

```vue
<template>
  <div style="text-align: center;margin: 0 20px">
    <div style="margin-top: 150px">
      <div style="font-size: 25px">登录</div>
      <div style="font-size: 14px;color: darkgray">在进入系统前请先输入用户名和密码进行登录</div>
    </div>

    <div style="margin-top: 50px">
      <el-form :model="form" :rules="rules" ref="formRef">
        <!--用户名-->
        <el-form-item prop="username">
          <el-input v-model="form.username" maxlength="10" type="text" placeholder="用户名/邮箱">
            <!--使用element的用户图标-->
            <template #prefix>
              <el-icon>
                <User/>
              </el-icon>
            </template>
          </el-input>
        </el-form-item>
        <!--密码-->
        <el-form-item prop="password">
          <el-input type="password" maxlength="20" style="margin-top: 10px" placeholder="密码">
            <template #prefix>
              <el-icon>
                <Lock/>
              </el-icon>
            </template>
          </el-input>
        </el-form-item>
        <!--左右布局：记住我和忘记密码-->
        <el-row style="margin-top: 5px">
          <el-col :span="12" style="text-align: left">
            <el-form-item>
              <el-checkbox label="记住我" v-model="form.remember" />
            </el-form-item>
          </el-col>
          <el-col :span="12" style="text-align: right">
            <el-link>忘记密码?</el-link>
          </el-col>
        </el-row>
      </el-form>
    </div>

    <!--登录按钮-->
    <div style="margin-top: 40px">
      <el-button @click="userLogin()" style="width: 270px;border-radius: 3px" type="success" plain >立即登录</el-button>
    </div>
    <!--提示注册-->
    <el-divider>
      <span style="color: gray;font-size: 13px">没有账户？</span>
    </el-divider>
    <!--注册按钮-->
    <el-button style="width: 270px;border-radius: 3px" type="warning" plain>注册账号</el-button>
  </div>
</template>
```



##### 9.4.3 register

```vue
<template>
  <div style="text-align: center;margin: 0 25px">
    <div style="margin-top: 100px">
      <div style="font-size: 25px">注册新用户</div>
      <div style="font-size: 14px;color: darkgray">欢迎注册，请在下方填写相关信息</div>
    </div>
    <!--注册表单-->
    <div style="margin-top: 60px">
      <!--绑定自定义表单、加上rules规定表单规则-->
      <el-form :model="form" :rules="rules">
        <!--prop绑定校验规则中的名字-->
        <el-form-item prop="username">
          <!--用户名-->
          <el-input v-model="form.username" type="text" placeholder="用户名">
            <template #prefix>
              <el-icon><User/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="password">
          <!--密码-->
          <el-input v-model="form.password" type="password" placeholder="密码">
            <template #prefix>
              <el-icon><Lock/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="password_repeat">
          <!--重复密码-->
          <el-input v-model="form.password_repeat" type="password" placeholder="重复密码">
            <template #prefix>
              <el-icon><Lock/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="email">
          <!--邮箱地址-->
          <el-input v-model="form.email" type="email" placeholder="电子邮箱地址">
            <template #prefix>
              <el-icon><Message /></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="code">
          <!--邮箱验证-->
          <!--布局：不太懂分栏部分，厉害的家人们敬请补充和说明-->
          <el-row :gutter="27">
            <el-col :span="15">
              <el-input v-model="form.code" type='text' placeholder="请输入验证码">
                <template #prefix>
                  <el-icon><EditPen /></el-icon>
                </template>
              </el-input>
            </el-col>
            <el-col :span="1"></el-col>
            <el-button type="success" plain>获取验证码</el-button>
          </el-row>
        </el-form-item>
      </el-form>

    </div>
```































