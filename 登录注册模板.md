# 前后端分离项目模板基于token

包括登录、注册和密码重置等功能，可以二次开发编写具体场景下的应用程序

- 登录功能（支持用户名、邮箱登录）
- 注册用户（通过邮箱注册）
- 重置密码（通过邮箱重置密码）



## 后端

### 1 创建项目

#### 1.1 idea创建springboot项目

![image-20231228124927308](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228124927308.png)

#### 1.2 导入依赖

![image-20231228125004146](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228125004146.png)

#### 1.3 配置maven

![image-20231228125151992](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228125151992.png)

#### 1.4 清理干净项目

![image-20231212114532378](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114532378.png)

因为是前后端分离项目，后端不涉及前端页面，所以就把static、templates删掉

![image-20231212114718804](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114718804.png)



### 2 配置

#### 2.1 配置数据源

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/community?useUnicode=true&characterEncoding=utf-8
    username: root
    password: 123456
```

#### 2.2 配置springsecurity





##### 2.2.1 springsecurity配置类

![image-20231228132504898](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228132504898.png)

因为是前后端分离项目，所以肯定不是走springboot的服务器，要走前端的服务器

所以，我要把登陆等功能的接口单独定义出来

```java
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                //验证请求拦截和放行配置
                //爆红了背刺了，6.1版本更新这个方法过时了
                /*.authorizeHttpRequests()
                .anyRequest().permitAll()*/
                .authorizeHttpRequests(conf->conf
                        .requestMatchers("/api/auth/**").permitAll()    //所有验证的请求再用户没有登录的时候要允许通过
                        .anyRequest().authenticated()   //任何请求都不允许通过
                )
                //登录配置
                .formLogin(conf -> conf
                        .loginProcessingUrl("/api/auth/login")
                )
                //登出配置
                .logout(
                        conf -> conf
                        .logoutUrl("api/auth/logout")
                )
                .build();   //构建，返回默认的SecurityFilterChain对象
    }

    

}
```

运行测试以下，密码默认生成在控制台

![image-20231228181648025](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228181648025.png)

测试成功



当前台调用了我们后端的接口之后，我们要返回一个json的数据，告诉前端==>登录成功了或登出成功了 这样的信息

所以我们要重写并封装 处理我们登录成功或失败 的接口方便我们调用

```java
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        ...
 		//登录配置
        .formLogin(conf -> conf
                   .loginProcessingUrl("/api/auth/login")
                   .successHandler(this::onAuthenticationSuccess)
                   .failureHandler(this::onAuthenticationFailure)
        )
        //登出配置
        .logout(conf->conf
                   .logoutUrl("api/auth/logout")
                   .logoutSuccessHandler(this::onLogoutSuccess)
        )
            
    }
    
    //登录成功后的处理
    /**
     *
     * @param request   请求
     * @param response  响应
     * @param authentication    请求成功后的验证信息
     * @throws IOException  io异常
     * @throws ServletException servlet异常
     */
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException, ServletException {
        response.getWriter().write("登陆成功");
    }

    //登录失败后的处理
    public void onAuthenticationFailure(HttpServletRequest request,
                                        HttpServletResponse response,
                                        AuthenticationException exception) throws IOException, ServletException {

    }

    //登出成功的处理
    //虽然登出成功和登陆成功的参数一样，但由于我们在登出的时候会写一个让jwt失效的功能，所以不能写在一起
    public void onLogoutSuccess(HttpServletRequest request,
                                HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {

    }
            
}
```

配置一些其他设置，把csrf关掉并把sessionManager改成无状态

```java
...
//登出配置
.logout(conf->conf
        .logoutUrl("api/auth/logout")
        .logoutSuccessHandler(this::onLogoutSuccess)    //登出成功的处理
)
//取消CSRF保护
.csrf(AbstractHttpConfigurer::disable)
//因为我们现在是无状态的前后端分离跟有状态的前后端分离区别：session不需要去维护用户信息，因为用户信息都在JWT里面
//所以我们把sessionManagement改成无状态，让security不去处理session
.sessionManagement(conf->conf
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS) //改成无状态
)
.build();   //构建，返回默认的SecurityFilterChain对象
...
```

启动项目，测试

![image-20231228180057176](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228180057176.png)

![image-20231228183137996](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228183137996.png)





##### 2.2.2 实体类

​	创建记录类RestBean接收信息，返回更标准的数据,方便前端进行一个统一的判断

```java
/**
 *
 * @param code  状态码
 * @param data  数据
 * @param message   异常信息
 * @param <T>   具体的数据的类型不确定
 */
public record RestBean<T>(int code, T data,String message) {

    //请求成功
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200,data,"请求成功");
    }
    //默认的请求成功
    public static <T> RestBean<T> success(){
        return success(null);
    }
    public String asJsonString(){
        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);   //WriteNull 不加上的话，前端的lang就没有了
    }


    //请求失败
    public static <T> RestBean<T> failure(int code, String message){
        return new RestBean<>(code,null,message);
    }

}
```



##### 2.2.3 登录成功

在security配置类中输出实体类信息，并转换成json格式

导入fastjson依赖后

在登陆成功处输出实体类信息

```java
//登录成功后，
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
    //配置编码
    response.setContentType("application/json");
    response.setCharacterEncoding("utf-8");

    response.getWriter().write(RestBean.success().asJsonString());
}
```

![image-20231228202255570](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231228202255570.png)

> ##### 为什么要转换成json数据
>
> 因为前端需要的就是这样的数据，前端会将json直接解析，非常方便



##### 2.2.4 登录失败

在security配置类定义登录失败接口

```java
//登录失败
public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
  //配置编码
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");

        response.getWriter().write(RestBean.failure(401,exception.getMessage()).asJsonString());
    
}
```

![image-20231212180940715](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212180940715.png)



##### 2.2.5 未授权

当访问的是未定义的接口，就返回未授权

此时，要在build方法前调用exceptionHandler的entrypoint方法

```java
//在未授权时会调用这个commence方法，输出失败的信息
.exceptionHandling()
.authenticationEntryPoint(this::onAuthenticationFailure)
.and()
.build();
```

![image-20231212182052006](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212182052006.png)









### 3 结构化

#### 3.1 必要依赖

##### fastjson

 将字符串转换成json的工具类

```xml
<!-- 字符串转换成json -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.44</version>
</dependency>

```

##### lombok

```xml
<!-- lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>
```





#### 3.2 config配置包

config

- `SecurityConfiguration `：security配置类
- 



#### 3.3 entity实体包

entity

- `RestBean `接收信息的实体类
- 



#### 3.4 service层



#### 3.5 mapper层







### 4 数据库设计

#### 建库

创建community的数据库

![image-20231212183435823](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212183435823.png)

#### 建表

```sql
create table `db_account`
(
    `id`            int not null auto_increment,
    `username`      varchar(255) default null,
    `email`         varchar(255) default null,
    `password`      varchar(255) default null,
    primary key (`id`)
) engine = innodb auto_increment = 4 default charset = utf8mb4;
```



#### 生成密码

在test类中加密“123456”的密码

```java
@Test
void contextLoads() {
    BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    //$2a$10$RQ4LuWr5hL73VDxztxJGu.lAwCTHustBif5sKiKK9866u.1m1LUaS
    System.out.println(encoder.encode("123456"));
}
```



#### 存一条数据

把admin的用户名和加密后的密码存入一条

![image-20231212184556513](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212184556513.png)

#### 规范

用户名和邮箱必须是唯一的：

![image-20231213173807593](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213173807593.png)

![image-20231213173844273](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213173844273.png)



用户名不能写成邮箱形式与其他用户邮箱冲突：





### 5 对接数据库

#### 5.1 创建service层和mapper层

![image-20231213172942382](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213172942382-1702459783240-1.png)

#### 5.2 创建user实体类

```java
@Data
public class Account {
    int id;     //id
    String username;    //用户名
    String email;       //密码
    String password;    //邮箱
}
```

#### 5.3 创建UserMapper

```java
@Mapper
public interface UserMapper {

    //根据用户名或密码找到用户
    @Select("select * from db_account where username = #{text} or email = #{text}")
    Account findAccountByNameOrEmail(String text);

}
```

#### 5.4 创建AuthorizeService类为权限校验的服务

```java
@Service
public class AuthorizeService implements UserDetailsService {   //实现UserDetailsService接口从数据库中取东西

    //注入mapper
    @Resource
    UserMapper mapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //
        if (username == null){
            throw new UsernameNotFoundException("用户名不能为空");
        }
        Account account = mapper.findAccountByNameOrEmail(username);
        //获取的account用户对象，如果为空则说明，没有从数据库中取到该对象，说明用户名或密码错误
        if (account == null){
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        return User
                .withUsername(account.getUsername())
                .password(account.getPassword())
                .roles("user")
                .build();
    }
}
```



#### 5.5 继续配置security配置类，加入service服务

```java
    //注入写好的用户权限服务
    @Resource
    AuthorizeService authorizeService;

....

    //配置用户权限的业务接口
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity security) throws Exception {
        return security
                .getSharedObject(AuthenticationManagerBuilder.class)
                .userDetailsService(authorizeService)
                .and()
                .build();
    }
    //密码默认校验
    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
```



#### 5.6 启动测试

![image-20231213180530339](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213180530339.png)

后台不再生成密码，因为我们已经配置了自己的用户验证服务--**AuthorizeService**

登录成功

![image-20231213181327338](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213181327338.png)

对接好数据库没问题了，我们来丰富前端页面和封装axios



### 6 解决跨域问题

反正我没遇到跨域问题，但确实有这个问题，我们就来解决一下

在security配置类中

```java
        //解决跨域问题
        .cors()
        //跨域配置源
        .configurationSource(this.corsConfigurationSource())
        .and()
.......
    //配置跨域问题
    //不用注册bean
    private CorsConfigurationSource corsConfigurationSource(){
        CorsConfiguration cors = new CorsConfiguration();
        //配置所有的访问都可以跨域
        //线上不可以这样配置，应该配置线上前端服务器的ip以保证你自己可以跨域就行了
        cors.addAllowedOriginPattern("*");
        //cors.addAllowedOriginPattern("http://localhost:5173");
        //跨域允许cookie
        cors.setAllowCredentials(true);
        //
        cors.addAllowedHeader("*");
        cors.addAllowedMethod("*");
        cors.addExposedHeader("*");

        //封装配置源
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        //注册，所有的请求都走我们这个cors配置
        source.registerCorsConfiguration("/**",cors);

        return source;
    }   
```

启动前后端，把数据库中的用户名、密码用来登录，测试成功

![image-20231215223047197](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231215223047197.png)





解决跨域问题后，我们去前端来解决登出功能



### 7 登出成功的handler

```java
		//配置登出接口
        .logout()
        .logoutUrl("/api/auth/logout")
        //配置登出成功的处理----使用登录成功写的处理方法
        .logoutSuccessHandler(this::onAuthenticationSuccess)
        .and()
....
//登录成功
//登出成功
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        //设置编码格式
        response.setCharacterEncoding("utf-8");
        //通过请求url的结尾来判断登录还是登出
        if (request.getRequestURI().endsWith("login"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("登录成功")));
        else if (request.getRequestURI().endsWith("logout"))
            response.getWriter().write(JSONObject.toJSONString(RestBean.success("登出成功")));
    }
```

![image-20231216132529358](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216132529358.png)



### 8 记住我

用户点了记住我，才能记住密码，没点重新登录

remember不可能一直存在内存中，所以我们用jdbc持久化地去存储remember的token值，以达到保存remember的作用



```java
    
			//配置登出成功的处理----使用登录成功写的处理方法
            .logoutSuccessHandler(this::onAuthenticationSuccess)
            .and()
            //配置记住我
            .rememberMe()
            //配置参数值就为remember
            .rememberMeParameter("remember")
            .tokenRepository(tokenRepository)
            //设置token的过期时间 按秒算的
            .tokenValiditySeconds(3600*24*7)
            .and()
            //暂时关闭csrf校验
.....
	//持久化token仓库用于存remember
    @Bean
    public PersistentTokenRepository tokenRepository(){
        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
        //设置数据源
        jdbcTokenRepository.setDataSource(dataSource);
        //初始化持久化仓库的表,只需要第一次运行生成这个表，以后运行改成false，不创建就好了
        //jdbcTokenRepository.setCreateTableOnStartup(true);
        jdbcTokenRepository.setCreateTableOnStartup(false);
        return jdbcTokenRepository;
    }
```

当点击记住我登录成功后，数据库就会创建一个专门存token值的表，用作remember

![image-20231216181425142](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216181425142.png)

![image-20231216182213618](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216182213618.png)

记住我解决完后，我们去前端编写注册功能



### 9 邮箱验证功能



#### 9.1 创建邮箱校验相关类

##### 9.1.1 重新创建权限校验的服务

以前的服务类，改成服务实现类

```java
public interface AuthorizeService extends UserDetailsService {


	//邮箱校验
    boolean sendValidateEmail(String email);
}
```

##### 9.1.2 权限校验的服务实现类

```java
@Service
public class AuthorizeServiceImpl implements AuthorizeService {   //实现UserDetailsService接口从数据库中取东西

    //注入mapper
    @Resource
    UserMapper mapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //
        if (username == null){
            throw new UsernameNotFoundException("用户名不能为空");
        }
        Account account = mapper.findAccountByNameOrEmail(username);
        //获取的account用户对象，如果为空则说明，没有从数据库中取到该对象，说明用户名或密码错误
        if (account == null){
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        return User
                .withUsername(account.getUsername())
                .password(account.getPassword())
                .roles("user")
                .build();
    }


    @Override
    public boolean sendValidateEmail(String email) {
        /*
        1、生成验证码
        2、把邮箱和对应验证码放到redis中（过期时间三分钟，若剩余时间低于2分钟就可以重新发送邮件一次，重复此操作！）
        3、发送验证码到指定邮箱中
        4、若发送失败，则把redis里面刚刚插入的键值对删除
        5、若发送成功，也取出对应的验证码与前端输入的验证码进行比较，看是否一致
        */
        return false;
    }



}
```

##### 9.1.3 权限校验的控制类

`AuthorizeController.java`

```java
@RestController
//权限校验相关的映射
@RequestMapping("/api/auth")
public class AuthorizeController {

    @Resource
    AuthorizeService service;

    @PostMapping("/valid-mail")
    public RestBean<String> validateEmail(@RequestParam("email") String email) {
        if (service.sendValidateEmail(email)){
            return RestBean.success("邮件已发送，请注意查收");
        }else {
            return RestBean.failure(400,"邮件发送失败，请联系管理员");
        }
    }
}
```



#### 9.2 补充邮箱校验的具体功能





##### 9.2.2 spring-validation做安全校验

做进一步的安全校验，防止类似apipost或其他情况恶意攻击服务器，我们引入spring-validation，他会在请求到来时对接口进行验证



验证相关的请求全部要放行，不然就会被拦截





### 10





## 前端

### 1 创建项目

#### 1.1 webstorm创建create-vue项目

![image-20231212115824321](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115824321.png)

#### 1.2 更新并测试运行

![image-20231212115925412](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115925412.png)

#### 1.3 清理干净项目

```javascript
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

```vue
<script setup>

</script>

<template>

</template>

<style scoped>

</style>
```

![image-20231212120257781](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212120257781-1702353778372-1.png)



#### 1.4 必要依赖

开启科学上网，防止网络问题

##### 1.4.1 路由router



`npm i vue-router`



##### 1.4.2 element-ui



`npm install element-plus --save`

###### 按需导入

安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件

`npm install -D unplugin-vue-components unplugin-auto-import`



在vite配置文件中配置

```javascript
import {fileURLToPath, URL} from 'node:url'

import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue(),
        AutoImport({
            resolvers: [ElementPlusResolver()],
        }),
        Components({
            resolvers: [ElementPlusResolver()],
        }),
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('./src', import.meta.url))
        }
    }
})
```



###### 完整导入

按需导入后，我发现elmessage不正常显示，所以我又进行了完整导入

在mian.js中

```js
import 'element-plus/dist/index.css'
import ElementPlus from 'element-plus'

//使用element完整导入
app.use(ElementPlus)
```

消息正常显示了

![image-20231216122949243](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216122949243.png)



##### 1.4.3 axios

`npm install axios`

`npm install vue-axios`



#### 1.5 结构初始化



##### 1.5.1 views视图

- 


##### 1.5.2 component 组件

- 


##### 1.5.3 router路由

- 


##### 1.5.4 stores

- 


##### 1.5.5 assets

- 





### 2 登陆功能

#### 2.1 先写好布局

直接在app.vue组件中编写

```vue
<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">

    </div>
    <!--右半边 固定宽度-->
    <div style="width: 300px;background-color: aquamarine">

    </div>
  </div>
</template>
```

![image-20231213183319305](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213183319305.png)

在最外层`index.html`中设置外边距为0去掉空白

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
    <style>
        body{
            margin: 0;
        }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

![image-20231213183637611](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231213183637611.png)



#### 2.2 登录界面

```vue
<script setup>
//导入element的图标组件User、lock
import {User} from '@element-plus/icons-vue'
import {Lock} from '@element-plus/icons-vue'
</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/rain.jpg"/>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <div style="text-align: center;margin: 0 20px">
        <div style="margin-top: 150px">
          <div style="font-size: 25px">登录</div>
          <div style="font-size: 14px;color: darkgray">在进入系统前请先输入用户名和密码进行登录</div>
        </div>

        <div style="margin-top: 50px">
          <!--用户名-->
          <el-input type="text" placeholder="用户名/邮箱">
            <!--使用element的用户图标-->
            <template #prefix>
              <el-icon><User /></el-icon>
            </template>
          </el-input>
          <!--密码-->
          <el-input type="password" style="margin-top: 13px" placeholder="密码">
            <template #prefix>
              <el-icon><Lock /></el-icon>
            </template>
          </el-input>
        </div>
        <!--左右布局：记住我和忘记密码-->
        <el-row>
          <el-col :span="12" style="text-align: left">
            <el-checkbox label="记住我" v-model="checked1" />
          </el-col>
          <el-col :span="12" style="text-align: right">
            <el-link>忘记密码?</el-link>
          </el-col>
        </el-row>
        <!--登录按钮-->
        <div style="margin-top: 25px;margin-top: 40px">
          <el-button style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
        </div>
        <!--提示注册-->
        <el-divider>
          <span style="color: gray;font-size: 13px">没有账户？</span>
        </el-divider>
        <!--注册按钮-->
        <el-button style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
      </div>
    </div>
  </div>
</template>

<style scoped>

</style>
```

![image-20231214181346023](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214181346023.png)



### 3 配置

#### 3.1 路由配置

登录界面写完就来配置路由

首先我们要配置两层路由

- 整个大框架的路由
- 页面的路由

##### 3.1.1 划分页面

把主页面的登录内容复制到视图目录中的欢迎视图中

![image-20231214182646468](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214182646468.png)

再把单独的登录用的表单移动到登录界面中完成划分

![image-20231214183040547](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214183040547.png)

再把空余部分用<router-view />填充

###### App.vue

```vue
<script setup>

</script>

<template>
  <router-view />
</template>

<style scoped>

</style>
```

###### WelcomeView.vue

```vue
<script setup>


</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/rain.jpg"/>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <router-view />
    </div>
  </div>
</template>

<style scoped>

</style>
```

###### LoginPage.vue

```vue
<script setup>
//导入element的图标组件User、lock
import {Lock, User} from "@element-plus/icons-vue";

</script>

<template>
  <div style="text-align: center;margin: 0 20px">
    <div style="margin-top: 150px">
      <div style="font-size: 25px">登录</div>
      <div style="font-size: 14px;color: darkgray">在进入系统前请先输入用户名和密码进行登录</div>
    </div>

    <div style="margin-top: 50px">
      <!--用户名-->
      <el-input type="text" placeholder="用户名/邮箱">
        <!--使用element的用户图标-->
        <template #prefix>
          <el-icon>
            <User/>
          </el-icon>
        </template>
      </el-input>
      <!--密码-->
      <el-input type="password" style="margin-top: 13px" placeholder="密码">
        <template #prefix>
          <el-icon>
            <Lock/>
          </el-icon>
        </template>
      </el-input>
    </div>
    <!--左右布局：记住我和忘记密码-->
    <el-row>
      <el-col :span="12" style="text-align: left">
        <el-checkbox label="记住我" v-model="checked1"/>
      </el-col>
      <el-col :span="12" style="text-align: right">
        <el-link>忘记密码?</el-link>
      </el-col>
    </el-row>
    <!--登录按钮-->
    <div style="margin-top: 25px;margin-top: 40px">
      <el-button style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
    </div>
    <!--提示注册-->
    <el-divider>
      <span style="color: gray;font-size: 13px">没有账户？</span>
    </el-divider>
    <!--注册按钮-->
    <el-button style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
  </div>
</template>

<style scoped>

</style>
```



##### 3.1.2 路由配置文件

创建router文件夹和router主配置文件

![image-20231214183756138](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214183756138.png)

编写路由配置

```js
import {createRouter, createWebHistory} from "vue-router";

const router = createRouter({
    history:createWebHistory(import.meta.env.BASE_URL),
    routes:[
        
    ]
})

//导出路由
export default router;
```

主配置文件`main.js`调用上面配置好的router

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from "@/router/index.js";

const app = createApp(App)

//使用路由
app.use(router)

app.mount('#app')
```



##### 3.1.3 编写路由

在router/index.js中编写路由

```js
routes:[
    {
        path:'/',       //路由地址
        name:'welcome', //路由名
        component:()=>import('@/views/WelcomeView.vue'),    //路由所引用的组件
        //子路由
        children:[
            {
                path:'',
                name:'welcome-login',
                component:()=>import('@/components/welcome/LoginPage.vue')
            }
        ]
    }
]
```

##### 3.1.4 主页路由

与welcome路由并列

```js
,
{
    path:'/index',
    name:'index',
    component:()=>import('@/views/IndexView.vue')
}
```

测试

![image-20231214202717243](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214202717243.png)



##### 3.1.5 注册路由

```js
//子路由
children:[
    //登录
    {
        path:'',
        name:'welcome-login',
        component:()=>import('@/components/welcome/LoginPage.vue')
    },
    //注册
    {
        path:'register',
        name:'welcome-register',
        component:()=>import('@/components/welcome/RegisterPage.vue')
    }
```







### 4 主题内容

在welcome.vue中的左半边图片上加上主题内容

```vue
<script setup>


</script>

<template>
  <!--总体框架-->
  <div style="width: 100vw;height: 100vh;overflow: hidden;display: flex">
    <!--左半边-->
    <div style="flex: 1;background-color: antiquewhite">
      <el-image style="width: 100%;height: 100%;" fit="cover" src="src/assets/mao3.jpg"/>
    </div>
    <!--设置主题内容：绝对定位以便在图片上写内容 -->
    <div class="welcome-title">
      <div>模板</div>
      <p>学习登陆注册模板</p>
    </div>
    <!--右半边 固定宽度-->
    <div style="width: 400px;background-color: white">
      <router-view/>
    </div>
  </div>
</template>

<style scoped>
.welcome-title {
  position: absolute;
  left: 40px;
  bottom: 45px;

}

.welcome-title div {
  color: white;
  font-size: 60px;
  font-weight: bold;
  text-shadow: 0 1px 8px blanchedalmond;
}
.welcome-title p {
  color: white;
  top: 10px;
}
</style>
```

![image-20231214201618439](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231214201618439.png)





### 5 主页

简单写一下，做个样子

创建IndexView.vue视图组件，并配置路由测试

```vue
<script setup>

</script>

<template>
  <div>welcome to template page</div>
  <!--登出按钮-->
  <div style="margin-top: 10px">
    <!--plain 为el-button的朴素样式-->
    <el-button type="danger" plain>登出</el-button>
  </div>
</template>

<style scoped>

</style>
```



6



### 7 前后端连接

我们安装依赖axios后，利用它来做异步请求工具，动态向后端发送请求完成登录、登出等功能



#### 7.1 统一封装axios

##### 7.1.1 get、post

创建net文件夹和index.js

```js
//引入axios
import axios from "axios";
import {ElMessage} from "element-plus";


//一般error就用默认的就行了，所以
//我们自定义一个默认的错误回调函数
const defaultError = (err) => {
    // 控制台发出错误,并把一些信息打印出来
    console.error(err)
    // 用element的接口: ElMessage来弹一个弹窗,打印错误信息
    ElMessage.warning('发生了错误,请联系管理员')
}

//自定义一个默认的失败回调函数
/*
    message     失败的信息
*/
const defaultFailure = (message) => {
    // 控制台发出警告,并把一些信息打印出来
    console.warn(`错误信息:${message}`)

    // 用element的接口: ElMessage来弹一个弹窗,打印失败信息
    ElMessage.warning(message)
}



function post(url,data,success,failure=defaultFailure,error=defaultError){  //这里failure、error使用了自定义的默认回调函数
    //封装的就是axios的post方法
    axios.post(url,data,{
        //请求头
        headers:{
            'Content-Type':'application/x-www-form-urlencoded'
        },
        //发起请求时，是否携带cookie
        //因为我们这个springboot服务器每次请求时，带上cookie才知道我们是哪一个用户，jwt时就不用cookie了
        withCredentials:true
    }).then(({data})=>{   //then就是直接去处理数据，data是后端创建的RestBean封装返回消息的message、status、success
        //如果访问成功---就是用success回调函数
        if (data.success){
            success(data.message,data.status)
        }else {
            //失败---用failure回调函数
            failure(data.message,data.status)
        }

    }).catch(error) //捕获到异常，就直接error
}

//再封装一个get，对比post
//不需要data
function get(url,success,failure=defaultFailure,error=defaultError){  //这里failure、error使用了自定义的默认回调函数
    //封装的就是axios的post方法
    axios.get(url,{
        //get不需要返回请求头
        /*headers:{
            'Content-Type':'application/x-www-form-urlencoded'
        },*/
        //发起请求时，是否携带cookie
        //因为我们这个springboot服务器每次请求时，带上cookie才知道我们是哪一个用户，jwt时就不用cookie了
        withCredentials:true
    }).then(({data})=>{   //then就是直接去处理数据，data是后端创建的RestBean封装返回消息的message、status、success
        //如果访问成功---就是用success回调函数
        if (data.success){
            success(data.message,data.status)
        }else {
            //失败---用failure回调函数
            failure(data.message,data.status)
        }

    }).catch(error) //捕获到异常，就直接error
}


//暴露出去定义的外部方法就可以使用了
export {get,post}
```

封装好方法，配置连接后端服务器

在main.js中

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from "@/router/index.js";
import axios from "axios";

const app = createApp(App)

//使用路由
app.use(router)
//配置连接后端服务器
axios.defaults.baseURL = 'http://localhost:8080'

app.mount('#app')
```

##### 7.1.2 登陆页面实现登录功能

数据绑定

```js
<script setup>
//导入element的图标组件User、lock
import {Lock, User} from "@element-plus/icons-vue";
import {ElMessage} from "element-plus";
import {post} from "@/net/index.js";
import router from "@/router/index.js";
import {reactive} from "vue";

//保存表单的数据
const form = reactive(
    {
      username:'',
      password:'',
      remember:false
    }
)

//登录接口
const login = ()=>{
  if (!form.username || !form.password){//先判断以下是否填写了用户名和密码
    ElMessage.warning("请填写用户名和密码")
  }else {
    //正常情况直接发了
    //引入我们net文件夹内封装的post方法
    post('/api/auth/login',
        {
          username:form.username,
          password:form.password,
          remember:form.remember
        }),
        (message)=>{    //登录成功，跳转index页面
          ElMessage.success(message)
          router.push('/index')
        }

  }
}
</script>
```

前端组件绑定

```vue
<el-input v-model="form.username" type="text" placeholder="用户名/邮箱">
...
<el-input v-model="form.password" type="password" style="margin-top: 13px" placeholder="密码">
...
<el-col :span="12" style="text-align: left">
    <el-checkbox label="记住我" v-model="form.remember"/>
</el-col>
...
<!--登录按钮-->
<div style="margin-top: 40px">
  <el-button @click="login()" style="width: 270px;border-radius: 3px" type="success">立即登录</el-button>
</div>
```

直接登录来测试前端，成功的话走后端，报跨域问题也走后端

封装好方法并暴露在前端进行数据绑定后，就可以去后端进行使用了！！



#### 7.2 登出功能

在IndexView组件

```js
<script setup>
import {get} from '@/net/index.js'
import {ElMessage} from "element-plus";
import router from "@/router/index.js";
const logout=()=>{
  //调用封装的get方法来访问后端限制的登出映射
  get('/api/auth/logout',(message)=>{
    //成功的话，就提示登出成功
    ElMessage.success('登出成功')
    //跳转到登录页面
    router.push('/')
  })
}
</script>
...
<el-button @click="logout()" type="danger" plain>登出</el-button>
```

测试登出发现302了

![image-20231215224723844](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231215224723844.png)

他给我重定向到login界面了

![image-20231215224929838](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231215224929838.png)

所以这时候，我们应该到后端，配置一下登出成功后的handler





### 8 注册页面

#### 8.1 创建组件并配置

创建RegisterPage.vue放到组件目录中与登录组件平级

![image-20231216182703563](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216182703563.png)

到路由配置中配置注册页面的路由

配置好后，组件绑定路由，并测试

`LoginPage.vue`:

```vue
<!--注册按钮-->
<el-button @click="router.push('/register')" style="width: 270px;border-radius: 3px" type="warning">注册账号</el-button>
```

右半边空白的，测试成功

![image-20231216183415048](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216183415048.png)





#### 8.2 注册页面展示

- 用户名
- 密码
- 密码确认
- 邮箱验证
- 验证码
- 确定

登陆页面代码做参考，复制过来修改

```vue
<script setup>

import {Lock, User, Message, EditPen} from "@element-plus/icons-vue";
import router from "@/router/index.js";
</script>

<template>
  <div style="text-align: center;margin: 0 25px">
    <div style="margin-top: 100px">
      <div style="font-size: 25px">注册新用户</div>
      <div style="font-size: 14px;color: darkgray">欢迎注册，请在下方填写相关信息</div>
    </div>
    <!--注册表单-->
    <div style="margin-top: 60px">
      <!--用户名-->
      <el-input type="text" placeholder="用户名">
        <template #prefix>
          <el-icon><User/></el-icon>
        </template>
      </el-input>
      <!--密码-->
      <el-input style="margin-top: 11px" type="password" placeholder="密码">
        <template #prefix>
          <el-icon><Lock/></el-icon>
        </template>
      </el-input>
      <!--重复密码-->
      <el-input style="margin-top: 11px" type="password" placeholder="重复密码">
        <template #prefix>
          <el-icon><Lock/></el-icon>
        </template>
      </el-input>

    </div>
    <el-input style="margin-top: 11px" type="email" placeholder="电子邮箱地址">
      <template #prefix>
        <el-icon><Message /></el-icon>
      </template>
    </el-input>
    <!--邮箱验证-->
    <div style="margin-top: 11px">
      <!--布局：不太懂分栏部分，厉害的家人们敬请补充和说明-->
      <el-row>
        <el-col :span="14">
          <el-input type='text' placeholder="请输入电子邮件验证码">
            <template #prefix>
              <el-icon><EditPen /></el-icon>
            </template>
          </el-input>
        </el-col>
        <el-col :span="3"></el-col>
        <el-button type="success" plain>获取验证码</el-button>
      </el-row>
    </div>
    <div style="margin-top: 75px">
      <el-button type="warning" style="width: 270px;border-radius: 3px" plain>立即注册</el-button>
    </div>
    <div style="margin-top: 20px;">
      <!--element有下沉问题，要不就一块下沉要不就上移2px-->
      <!--<el-link disabled>已有帐号？</el-link>&nbsp;<el-link type="primary" :underline="false">立即登录</el-link>-->
      <span style="font-size: 14px;line-height: 15px;color: gray">已有帐号？</span>
      <el-link type="primary" :underline="false" style="translate: 0 -2px" @click="router.push('/')">立即登录</el-link>
    </div>
  </div>
</template>

<style scoped>

</style>
```

测试“立即登录”是否跳转成功

先点注册账号、再点立即登录，成功！

![image-20231216202916478](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216202916478.png)



#### 8.3 数据绑定

```vue
<script setup>

import {Lock, User, Message, EditPen} from "@element-plus/icons-vue";
import router from "@/router/index.js";
import {reactive} from "vue"

//注册表单数据绑定
const form = reactive({
  username:'',
  password:'',
  password_repeat:'',
  email:'',
  code:''
})

</script>
<template>
	<el-input v-model="form.username" type="text" placeholder="用户名">
    ...
    <el-input v-model="form.password" style="margin-top: 11px" type="password" placeholder="密码">
    ...
    ...
</template>
```

可以正常输入了，nice

![image-20231216204942112](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216204942112.png)



#### 8.4 电子邮箱校验

在校验之前，最好一定要进行**[页面优化](###9 页面优化)**，全看完再来

我们如何判断电子邮箱是否可以接收验证码？即判断电子邮箱是否有效

```js
//ref
import {ref} from "vue"
const formRef = ref()
//电子邮箱是否有效  默认无效
const isEmailValid = ref(false)
//如果电子邮箱无效，那就把获取验证码的按钮disable掉

//那什么时候更新呢，我们
const onValidate=(prop,isValid)=>{
  if (prop === 'email'){
    isEmailValid.value = isValid
  }
}

//验证整个表单内容，对整个表单内容进行检查，把方法给到自己注册按钮
const register = ()=>{
  formRef.value.validate((isValid)=>{
    if (isValid){ //都正常

    }else { //有问题
      ElMessage.warning('请完整填写注册表单内容')
    }
  }).then()
}
```

```vue
<el-button type="warning" style="width: 270px;border-radius: 3px" @click="register()" plain>立即注册</el-button>
```



我们后端补充发送邮件后，接着写前端的发送验证码功能







### 9 页面优化



#### 9.1 内置过渡动画

在`WelcomeView.vue`页面组件，添加右半边登录注册转换的过渡动画，保证页面转换更流畅

```html
<!--右半边 固定宽度-->
<div style="width: 400px;background-color: white">
  <transition name="el-fade-in-linear">
    <router-view/>
  </transition>
```



#### 9.2 调整重叠位置

`WelcomeView.vue`:

```vue
<!--右半边 固定宽度-->
<div style="width: 400px;background-color: white;z-index: 1">
  <transition name="el-fade-in-linear">
    <router-view/>
  </transition>
```

保证左半边文字不会覆盖右半边登录注册模块



#### 9.3 控制台`transition`警告

```bash
[Vue Router warn]: <router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <transition>
    <component :is="Component" />
  </transition>
</router-view>
```

按着他的写就行了

在过渡动画位置加上插槽

```vue
<!--设置过渡动画、解决v-slot警告-->
<router-view v-slot="{ Component }">
  <transition mode="out-in" name="el-fade-in-linear">
    <component :is="Component" />
  </transition>
</router-view>
```



#### 9.4 表单校验

前端自己识别一些错误：格式错误、密码重复错误等

我们需要在表单外套一层element-plus给我们提供的表单`el-form  el-form-item`

我们在登录、注册页面分别套一层，并且去掉margin-top

##### 9.4.1 校验规则

我们需要自定义校验规则才能让前端识别错误

用户名可以由中英文字符、数字或它们的混合组成，但不能包含特殊字符

```txt
^[A-Za-z0-9\u4e00-\u9fa5]*$
```

![image-20231216215542980](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231216215542980.png)

```js
//校验用户名 username
const validateUsername = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('请输入用户名'))
  }else if (!/^[A-Za-z0-9\u4e00-\u9fa5]*$/.test(value)){//value包含特殊字符，就提示有特殊字符的异常
    callback(new Error('用户名不能包含有特殊字符，只能是中文、英文、数字或它们的混合'))
  }else{
    callback()    //没有问题！
  }
}
//校验密码
const validatePassword = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('密码不能为空！'))
  }else {
    callback()
  }
}
//校验重复密码  password_repeat
const validatePasswordRepeat = (rule,value,callback)=>{
  if (value===''){
    callback(new Error('请重新输入密码'))
  }else if (value!==form.password){  //是否等于表单的password
    callback(new Error('两次输入的密码不一致'))
  }else{
    callback()
  }
}
//自定义rules校验规则
const rules = {
  /*
    username  使用自定义的用户名校验方法，在聚焦或修改时校验，长度：3-11
  */
  username:[
    {validator:validateUsername,trigger:['blur','change']},
    {min:3,max:11,message:'用户名的长度在3~11之间',trigger:['blur','change']}
  ],
  password:[
    {validator:validatePassword,trigger:['blur','change']},
    {min:6,max:20,message:'密码的长度在6~20之间',trigger:['blur','change']}
  ],
  password_repeat:[
    {validator:validatePasswordRepeat,trigger:['blur','change']}
  ],
  email:[
    {required: true, message: '请输入电子邮件地址', trigger: ['blur']},
    {type: 'email', message: '请输入合法的电子邮件地址', trigger: ['blur', 'change']}
  ],
  code:[
    {required: true, message: '请输入获取的验证码', trigger: ['blur']}
  ]
}

```



![image-20231218180256770](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231218180256770.png)



##### 9.4.2 login



##### 9.4.3 register

```vue
<template>
  <div style="text-align: center;margin: 0 25px">
    <div style="margin-top: 100px">
      <div style="font-size: 25px">注册新用户</div>
      <div style="font-size: 14px;color: darkgray">欢迎注册，请在下方填写相关信息</div>
    </div>
    <!--注册表单-->
    <div style="margin-top: 60px">
      <!--绑定自定义表单、加上rules规定表单规则-->
      <el-form :model="form" :rules="rules">
        <!--prop绑定校验规则中的名字-->
        <el-form-item prop="username">
          <!--用户名-->
          <el-input v-model="form.username" type="text" placeholder="用户名">
            <template #prefix>
              <el-icon><User/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="password">
          <!--密码-->
          <el-input v-model="form.password" type="password" placeholder="密码">
            <template #prefix>
              <el-icon><Lock/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="password_repeat">
          <!--重复密码-->
          <el-input v-model="form.password_repeat" type="password" placeholder="重复密码">
            <template #prefix>
              <el-icon><Lock/></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="email">
          <!--邮箱地址-->
          <el-input v-model="form.email" type="email" placeholder="电子邮箱地址">
            <template #prefix>
              <el-icon><Message /></el-icon>
            </template>
          </el-input>
        </el-form-item>
        <el-form-item prop="code">
          <!--邮箱验证-->
          <!--布局：不太懂分栏部分，厉害的家人们敬请补充和说明-->
          <el-row :gutter="27">
            <el-col :span="15">
              <el-input v-model="form.code" type='text' placeholder="请输入验证码">
                <template #prefix>
                  <el-icon><EditPen /></el-icon>
                </template>
              </el-input>
            </el-col>
            <el-col :span="1"></el-col>
            <el-button type="success" plain>获取验证码</el-button>
          </el-row>
        </el-form-item>
      </el-form>

    </div>
```































